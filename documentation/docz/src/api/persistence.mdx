---
name: "@harmonyjs/persistence"
route: /api/persistence
menu: API
---

# HarmonyJS Persistence

`@harmonyjs/persistence` handles the data of our application. It provides a convenient way to describe our models, and
connect them to our databases through accessors.

_**Note:** While not mandatory, [GraphQL](https://graphql.org/) is the main target of the Persistence module, and is needed_
_to take full advantage of HarmonyJS_


## Default export

`@harmonyjs/persistence` default export is the `Persistence() : PersistenceInstance` factory

This factory allows us to create a [`PersistenceInstance`](#persistenceinstance) object, which can be configured to handle our application's data.

<b style={{display: "block", marginBottom: "-1.5rem" }}>Sample usage</b>

```js
import Persistence from '@harmonyjs/persistence'

async function run() {
    // Create a new Persistence instance
    const persistence = Persistence()

    console.log('Initializing the Persistence instance...')

    // Start our Persistence instance
    await persistence.initialize({
        models: [...],
        adapters: {...},
    })

    console.log('Persistence instance initialized!')
}

run()
```

## Other exports

### Types

`@harmonyjs/persistence` also has another, named export: the `Types` factories. This object follows the following interface:

```
interface ITypes {
    String: IPropertyString
    Number: IPropertyNumber
    Float: IPropertyFloat
    Boolean: IPropertyBoolean
    ID: IPropertyID
    JSON: IPropertyJSON
    Date: IPropertyDate
    Reference: { of(model: string) : IPropertyReference }
    ReversedReference: { of(model: string): { on(field: string): IPropertyReversedReference }, on(field: string): { of(model: string): IPropertyReversedReference } }
    Schema: { of(schema: Schema): IPropertySchema }
    Array: { of(type: SchemaField): IPropertyArray }
}
```

Each member of `Types` is a factory for a specific `IProperty{Kind}`.

`IProperty` is an internal type of `@harmonyjs/persistence` describing a correct, sanitized Property in a schema.

`IProperty{Kind}` is a specialized `IProperty` containing a specific type.

<b style={{display: "block", marginBottom: "-1.5rem" }}>Sample usage</b>

```js
import { Types } from '@harmonyjs/persistence'

const schema = {
    someString: Types.String,
    someBoolean: Types.Boolean,
    someReference: Types.Reference.of('some-model'),
    someNestedSchema: Types.Schema.of({
        someNestedFloat: Types.Float,
        someNestedDate: Types.Date,
    }),
}

export default schema
```

## Exported types

Here is the list of all types exported by the `@harmonyjs/persistence` package, related to the persistence instance itself.

`@harmonyjs/persistence` also export types related to [Adapters](/plugins/adapters), but those are described in the Adapters documentation.

### `PersistenceConfig`

The `PersistenceConfig` object allows us to configure a Persistence instance. Here are the available options:

```ts
type PersistenceConfig = {
  models: Model[]
  adapters: Record<string, IAdapter>
  defaultAdapter?: string
  strict: boolean
  log: LoggerConfig
}
```
> Jump to:
[Model](#model),
[IAdapter](/plugins/adapters#iadapter),
[LoggerConfig](/api/logger#loggerconfig)

#### `PersistenceConfig::models`

List of [`Models`](#model) describing the data handled by the Persistence instance.

#### `PersistenceConfig::adapters`

Map of named [`Adapters`](/plugins/adapters) connecting the Persistence instance to databases. The key in the map is the
name of the adapter, used either to set a [`Model`](#model)'s specific adapter, or the default adapter using the next field.

#### `PersistenceConfig::defaultAdapter`

Default adapter name. If not provided, the first key found in the map will be used as default. If the map is empty, a `mock`
adapter will be used, mocking the schema.

#### `PersistenceConfig::strict`

Flag allowing the use of `strict` mode. `strict` mode results in CRUD queries and mutations only being generated in the output schema
if a `Scope` has been provided. See [`Scope`](#scope) for more details.

#### `PersistenceConfig::log`

Configuration of the way the persistence instance logs its actions. Refer to the [Log util documentation](/api/logger#loggerconfig)

### `PersistenceInstance`

The `PersistenceInstance` type represents the object returned when instantiating an `@harmonyjs/persistence`. It mostly exposes
lifecycle functions, as well as underlying elements such as the GraphQL resolvers or custom Controllers to be used with an `@harmonyjs/server` instance.

```ts
type PersistenceInstance = {
  configuration: PersistenceConfig
  logger: ILogger

  models: SanitizedModel[]
  events: IEvents
  context: PersistenceContext

  schema: string
  resolvers: Record<string, ModelResolver>
  controllers: {
    ControllerGraphQL: Controller<{ path: string, enablePlayground: boolean }>
    ControllerEvents: Controller<void>
  },

  initialize(configuration: Partial<PersistenceConfig>): Promise<void>
}
```
> Jump to:
[PersistenceConfig](#persistenceconfig),
[ILogger](/api/logger#ilogger),
[SanitizedModel](#sanitizedmodel),
[IEvents](#ievents),
[PersistenceContext](#persistencecontext),
[Controller](/plugins/controllers),
[ModelResolver](#modelresolver)

#### `PersistenceInstance::configuration`

Expose the currently applied configuration, which is the result of a merge between the configuration passed during initialization,
and the default configuration.

#### `PersistenceInstance::logger`

Expose the underlying logger, in order to be able to add custom logs using the Persistence namespace.

#### `PersistenceInstance::models`

Expose the computed Persistence models, as [`SanitizedModels`](#sanitizedmodel), which are compiled from the provided raw
[`Models`](#model).

#### `PersistenceInstance::events`

Expose the instance's Events handler, primarily used in [`Adapters`](/plugins/adapters) to signal an updated, created or
deleted document.

#### `PersistenceInstance::context`

Expose the instance's Context object, which is compiled for each request before being passed to GraphQL's resolvers.
See the [`PersistenceContext`](#persistencecontext) definition for more information.

#### `PersistenceInstance::schema`

Expose the computed GraphQL schema representing the instance's models.

#### `PersistenceInstance::resolvers`

Provide a map of resolvers by models. Each entry is an object containing the model's basic CRUD resolvers. See [`ModelResolver`](#modelresolver)
for more information.

#### `PersistenceInstance::controllers`

The `Persistence::controllers` object exposes two ready-to-use Controllers:
- `PersistenceInstance::controllers::ControllerGraphQL` can be used to expose a GraphQL endpoint configured with the Persistence instance schema.
Its constructor accepts one `configuration` argument, of the following type:
```ts
{
    path: string // The route on which to expose the GraphQL endpoint
    enablePlayground: boolean // Whether to enable the GraphQL Playground page on the endpoint
}
```
- `PersistenceInstance::controllers::ControllerEvents` can be used to forward our data events to the application's Socket.IO layer. It doesn't require
any configuration.

#### `PersistenceInstance::initialize`

Function accepting a PersistenceConfig object and launching the persistence instance with the given configuration.

The function actually takes a Partial representation of a PersistenceConfig object, meaning that each field is optional.
Non-provided mandatory fields will be filled with sensible default values.

Returns a Promise resolving once everything is correctly setup.

### `Model`

The `Model` type is used to describe a type of document handled by the Persistence instance. It has the following structure:

```ts
type Model = {
  name: string,

  schema: Schema
  computed?: Computed
  scopes?: Scopes

  adapter?: string
  external?: boolean
}
```
> Jump to:
[Schema](#schema),
[Computed](#computed),
[Scopes](#scopes)

#### `Model::name`

The name of the model. By convention, the name should be given as kebab-case (lowercase, hyphen-separated) and singular.

#### `Model::schema`

The schema describing what a document of this model looks like. This schema uses specific `Types` provided by HarmonyJS, which
enables the framework to understand it and convert it to various underlying structure: [Adapters](/plugins/adapters)'s specific typing system,
GraphQL schema and resolvers, etc...

Fields described in the Schema are primitive fields which should be stored in the underlying database.

#### `Model::computed`

The `computed` field allows to extend a model's capability beyond its schema by providing fields computed during runtime by merging
schema values (or by doing any other specific computing).

To learn how to use this field, refer to the [Computed](#computed) documentation.

#### `Model::scopes`

The `scopes` field is used to define access scopes for all basic CRUD functions created by HarmonyJS. A scope function receives
the arguments passed to the query by a client, and returns a new set of arguments sanitized by any means necessary.

The scope function is asynchronous, so any verification can be done. Be careful though, as the scope will be run for each query
and should therefore be as fast as possible.

#### `Model::adapter`

The `adapter` field should be a key from the Persistence instance Adapters map. If no adapter is provided for a model,
the instance's default adapter will be used

#### `Model::external`

The `external` boolean is only necessary for building a Federated service using [Apollo Federation](https://www.apollographql.com/docs/apollo-server/federation/introduction/).

Setting this boolean to `true` will tell HarmonyJS to mark the resulting GraphQL types as external, as well as not provide
default CRUD resolvers for this model which is handled by another service.

### `Schema`

The `Schema` type is used to define the `schema` field of a `Model`. It follows the following structure:

```ts
type SchemaField = IProperty | SchemaDescription | [SchemaField]
type SchemaDescription = { [key: string]: SchemaField }

type Schema = IPropertySchema | SchemaDescription
```

`IProperty` is an internal type of `@harmonyjs/persistence` describing a correct, sanitized Property in a schema.

`IPropertySchema` is a specialized `IProperty` describing a field that is itself a schema.


In other terms, a `Schema` can either be a valid `IPropertySchema`, or a `SchemaDescription` which is a plain JavaScript object
which can be used to construct an `IPropertySchema`. Most of the time, we will use a `SchemaDescription`.

A `SchemaDescription` is a map of `SchemaField`. A `SchemaField` is any valid child of a `SchemaDescription`, which includes :
- A valid `IProperty` (as returned by the [`Types`](#types) Factories)
- Another nested `SchemaDescription`
- An array of `SchemaField`, more precisely an array with only one element which is a `SchemaField`

### `Computed`

As mentioned in the [`Model`](#model) description, the `Computed` type is used to describe computed fields for a given schema.

It also allows the definition of specific `Queries` and `Mutations` for the generated GraphQL schema.

```ts
type Field = {
  resolve?: Resolver
  mode?: PropertyMode | PropertyMode[]

  type: SchemaField
  args?: Schema
}
type ExtendableField = {
  resolve?: Resolver
  mode?: PropertyMode | PropertyMode[]

  type: SchemaField
  args?: Schema

  extends?: ResolverEnum
}

type Computed = {
    fields?: Record<string, Field>
    queries?: Record<string, ExtendableField>
    mutations?: Record<string, ExtendableField>
    custom?: Record<string, Record<string, Resolver>>
}
```
> Jump to:
[Resolver](#resolver),
[ResolverEnum](#resolverenum),
[PropertyMode](#propertymode),
[SchemaField](#schema),
[Schema](#schema)

#### `Computed::fields`

`Computed::fields` is a map of `Field`. Each `Field` is a description of a new property to append to the model's schema, with the following properties:

- `resolve`: asynchronous function returning the value for the field.
- `mode`: whether this field is to inject in _output_ types, _input_ types, or both. Defaults to _output_ types only.
- `type`: the type of the field. Can be any valid [`SchemaField`](#schema)
- `args`: the (optional) map of arguments the field can take. Can be any valid [`Schema`](#schema)

#### `Computed::queries`

`Computed::queries` define fields that will be injected to the `Query` type of the resulting GraphQL schema. Except when using `extends`, the queries are not
actually linked to the model they are defined on. However by convention, it is a best practice to keep all queries related to a model in the model definition.

A query field can take two forms. It can either be a `Field` just like described in the [`Computed::fields`](#computedfields) map, or it can skip the `args` and `type`
parameters and use the `extends` parameter instead.

`extends` takes the name of one of the basic CRUD resolvers, and the `args` and `type` parameters will be automatically filled for the
corresponding resolver for the given model.

#### `Computed::mutations`

`Computed::mutations` works exactly the same as [`Computed::queries`](#computedqueries), but for GraphQL mutations.

#### `Computed::custom`

For advanced use only, the `Computed::custom` field allows anyone to inject an arbitrary field resolver for an arbitrary type.

It is a map of map of resolver functions: the first level of the map corresponds to the type to inject a resolver to, the second
level of the map corresponds to the field to resolve, and finally the resolve function works just like in [`Computed::fields`](computedfields)

### `Scopes`

The `Scopes` type is used to describe the scope functions for a [`Model`](#model).

```ts
type ScopeParams = {
  args?: Record<string, any>
  context?: Record<string, any>
}
type Scope = (arg: ScopeParams) => Promise<Record<string, any>|undefined>
type Scopes = Partial<Record<ResolverEnum, Scope>>
```

It is a map that can define a scope function for each basic CRUD resolver provided by HarmonyJS. Each scope function takes the incoming
arguments from the query as well as the GraphQL Context, and returns a Promise which resolved to a modified (or not!) set of arguments
after whatever sanitation was necessary. It can also resolve to `undefined` or any falsy value to instruct the framework to use the original arguments as is.

### `PropertyMode`

Enumeration defining whether a field should be used in the _output_ or _input_ types.

```ts
export enum PropertyMode {
  INPUT = 'INPUT',
  OUTPUT = 'OUTPUT',
}
```

## Referenced types

### `IEvents`

```ts
interface IEvents {
  on(event : string, callback : (args: { document: any, model: SanitizedModel }) => void): void

  off(event : string, callback : (args: { document: any, model: SanitizedModel }) => void): void

  emit({ event, payload } : { event: string, payload: any }): void

  updated({ document, model } : { document: any, model: SanitizedModel }): void

  removed({ document, model } : { document: any, model: SanitizedModel }): void
}
```

This interface is implemented by the `PersistenceInstance::events` field. It is a management interface used either by [`Adapters`](/plugins/adapters)
as a way to signal the update or removal of a document, or by [`Controllers`](/plugins/controllers) to subscribe to those changes.

#### `IEvents::on`

Register a callback for the selected event.

#### `IEvents::off`

Unregister a callback for the selected event.

#### `IEvents::emit`

Emit an event, calling all the registered callbacks by passing them the given payload.

#### `IEvents::updated`

Helper used for emitting the `'updated'` event with a payload made of `{ document, model }`

#### `IEvents::removed`

Helper used for emitting the `'removed'` event with a payload made of `{ document, model }`


### `ModelResolver`

```ts
type ClassicResolverFunction = (arg: {
  source?: Record<string, any>, args?: Record<string, any>, context?: Record<string, any>, info?: GraphQLResolveInfo,
}) => any
type ReferenceResolverFunction = (arg: {
  source?: Record<string, any>, context?: Record<string, any>, info?: GraphQLResolveInfo, fieldName: string, foreignFieldName: string
}) => any

type ModelResolver =
  Record<AliasedResolverEnum, ClassicResolverFunction> &
  Record<'reference'|'references', ReferenceResolverFunction>
```
> Jump to:
[GraphQLResolveInfo](https://graphql.org/graphql-js/type/),
[AliasedResolverEnum](#resolverenum)

Exposed as a map in the `PersistenceInstance::resolvers` field, as well as passed as an argument to the [`Resolver`](#resolver) functions,
a `ModelResolver` is a map of default CRUD resolvers (see [`Resolver`](#resolver) for CRUD names).

Those resolvers are implemented in each [`Adapters`](/plugins/adapters) and can be used to retrieve and update documents in databases.

The special reference resolvers are mostly there for internal use, as they are only a specific implementation of the `read` resolver.

### `PersistenceContext`

The `PersistenceContext` type represents the Context provider object used for GraphQL resolvers. Its format is the following:

```
type PersistenceContextValue =
  string | number | boolean | null | { [key: string]: PersistenceContextValue } | PersistenceContextValue[]

export type PersistenceContext = {
  [key: string]: PersistenceContextValue | ((request: FastifyRequest) => any),
}
```
> Jump to: [FastifyRequest](https://www.fastify.io/docs/latest/Request/)

In other terms, each key is either a primitive, a map object or an array, or a specific function taking the incoming request
and returning anything.

If one wants to provide a function to the GraphQL context, it must be wrapped in another function first since each top-level
functions are executed to get the compiled context for each request.

### `SanitizedModel`

```ts
type SanitizedModel = {
  name: string

  schemas: {
    main: IPropertySchema
    computed: IPropertySchema
    queries: IPropertySchema
    mutations: IPropertySchema
  }

  resolvers: {
    computed: Record<String, Resolver>
    queries: Record<String, Resolver>
    mutations: Record<String, Resolver>
    custom: Record<string, Record<String, Resolver>>
  }

  scopes: Scopes

  adapter?: string
  external: boolean
}
```
> Jump to:
[IPropertySchema](#types),
[Resolver](#resolver),
[Scopes](#scopes)

The `SanitizedModel` type is the result of importing raw [`Models`](#model) when calling `PersistenceInstance::initialize`.

It is exposed to the outside world as a convenience, for advanced customization.

### `Resolver`

```ts

export type Resolver = (arg: {
  source: Record<string, any>
  args: Record<string, any>
  resolvers: Record<string, Record<ResolverEnum, (arg: any) => Promise<any>>>
  context: Record<string, any>
  info: GraphQLResolveInfo
}) => Promise<any>
```
> Jump to:
[ResolverEnum](#resolverenum),
[GraphQLResolveInfo](https://graphql.org/graphql-js/type/)

The `Resolver` function type describe the `resolve` fields of `Field` and `ExtendableField` elements found in a [`Computed`](#computed) object.

It is an asynchronous function charged with retrieving the value of a given field inside a type.

#### Resolver::arg::source

The source argument contains the parent object containing the field to resolve, as currently resolved by the GraphQL engine.
In the case of a `Field`, it is the raw document retrieved from the database. For an `ExtendableField` it will be `null` as those are
used to describe root queries. Finally in a `custom` resolver it can be any arbitrary object.

### `ResolverEnum`

```ts
type ResolverEnum = 'read'|'readMany'|'count'|'create'|'createMany'|'update'|'updateMany'|'delete'|'deleteMany'
type AliasedResolverEnum = ResolverEnum|'get'|'list'|'edit'|'editMany'
```

`ResolverEnum` contains the list of all default CRUD resolvers exposed by HarmonyJS. `AliasedResolverEnum` is the same list
extended with a few aliases for some CRUD actions.

- `read` (aliased `get`): retrieve one document based on a given filter, with optional skip parameter
- `readMany` (aliased `list`): retrieve an array of document based on a given filter, with optional pagination and sorting
- `count`: count documents based on a given filter
- `create`: create a new document entry
- `createMany`: create a bunch of documents in one query
- `update` (aliased `edit`): update a document based on its ID
- `updateMany` (aliased `editMany`): update an array of documents based on their IDs
- `delete`: delete a document based on its ID
- `deleteMany`: delete an array of documents based on their IDs
